(cluster-reads-into-otus)=
# How to cluster sequences into OTUs

![](#otu-warning)

[*De novo*](#q2-method-vsearch-cluster-features-de-novo), [closed-reference](#q2-method-vsearch-cluster-features-closed-reference), and [open-reference](#q2-method-vsearch-cluster-features-open-reference) clustering are currently supported in QIIME 2 using [vsearch](https://doi.org/10.7717/peerj.2584).
Definitions of the clustering approaches can be found in [](https://doi.org/10.7717/peerj.545).

These operations begin with `FeatureTable[Frequency]` and `FeatureData[Sequence]` artifacts, for example as could be generated by [`dada2 denoise-paired`](q2-method-dada2-denoise-paired), [`deblur denoise-16S`](q2-method-deblur-denoise-16S), or [`vsearch dereplicate-sequences`](q2-method-vsearch-dereplicate-sequences).

Here we'll illustrate applying open-reference clustering, and the other two approaches should be straight-forward to model from that command.

## Obtain the data

First, download sample metadata and a few data artifacts.
The data artifacts that we'll download are a "demux artifact" (i.e., `SampleData[SequencesWithQuality]`), and a collection of reference sequences for use in open-reference clustering.

:::{describe-usage}
:scope: cluster-reads-into-otus

sample_metadata = use.init_metadata_from_url(
   'sample-metadata',
   'https://www.dropbox.com/scl/fi/irosimbb1aud1aa7frzxf/sample-metadata.tsv?rlkey=f45jpxzajjz9xx9vpvfnf1zjx&st=nahafuvy&dl=1')
:::

:::{describe-usage}

demux = use.init_artifact_from_url(
   'demux',
   'https://www.dropbox.com/scl/fi/hpsl1hxa0kj3njhes7p64/demux-10p.qza?rlkey=e5brlu9xn4qcrqaan11z2oi7d&st=r9or2kur&dl=1')
:::

:::{describe-usage}

reference_seqs = use.init_artifact_from_url(
   'reference_seqs',
   'https://data.qiime2.org/2025.4/tutorials/otu-clustering/85_otus.qza')
:::

The data used in this guide were sequenced on Illumina MiSeq, and originally published in [](https://doi.org/10.48550/arXiv.2411.04148).
The data used here are subsampled to 10% of the original input sequences so the commands can be run quickly.
You can find the full dataset in [the study's Artifact Repository](https://doi.org/10.5281/zenodo.13887456).

## Generate the input artifacts

Open-reference clustering in QIIME 2 begins with:
- a `FeatureTable[Frequency]` and a corresponding `FeatureData[Sequence]`, and
- another `FeatureData[Sequence]` containing the reference sequences to cluster against.

To generate the `FeatureTable[Frequency]` and a corresponding `FeatureData[Sequence]`, we'll using [DADA2](https://doi.org/10.1038/nmeth.3869)'s `denoise-paired` action.

:::{describe-usage}

asv_seqs, asv_table, denoising_stats, base_transition_stats = use.action(
    use.UsageAction(plugin_id='dada2',
                    action_id='denoise_paired'),
    use.UsageInputs(demultiplexed_seqs=demux,
                    trim_left_f=0,
                    trunc_len_f=250,
                    trim_left_r=0,
                    trunc_len_r=250),
    use.UsageOutputNames(representative_sequences='asv_seqs',
                         table='asv_table',
                         denoising_stats='denoising_stats',
                         base_transition_stats='base_transition_stats'))
:::

## Cluster features

We now have all of the artifacts that we need to cluster the sequences.
In open-reference clustering, each input (i.e., query) sequence is searched against a reference collection of sequences (i.e., the subject sequences).
If the current query sequence matches a subject sequence at greater than or equal to the user-specified percent identity threshold (we'll use 85% here), the query sequence is mapped to that subject sequence.
If the query sequence doesn't match a subject sequence at the specified threshold, it becomes the centroid of a new OTU and that sequence is added to the reference collection of sequences.[^open-reference-definition]
We run this as follows:

:::{describe-usage}

clustered_sequences, clustered_table, new_reference_sequences = use.action(
    use.UsageAction(plugin_id='vsearch',
                    action_id='cluster_features_open_reference'),
    use.UsageInputs(table=asv_table,
                    sequences=asv_seqs,
                    reference_sequences=reference_seqs,
                    perc_identity=0.85),
    use.UsageOutputNames(clustered_sequences='otu_seqs',
                         clustered_table='otu_table',
                         new_reference_sequences='new_reference_seqs'))
:::

The outputs from `cluster-features-open-reference` are a `FeatureTable[Frequency]` artifact and two `FeatureData[Sequence]` artifacts.
One of the `FeatureData[Sequence]` artifacts represents the clustered sequences, while the other artifact represents the new reference sequences, composed of the reference sequences used for input, as well as the input sequences that were added to the reference.
The new reference sequences could be used for iterative open-reference clustering, as described in [](https://doi.org/10.7717/peerj.545).

These outputs can be used for all downstream analyses.
For example, let's summarize the OTU table.

:::{describe-usage}
use.action(
    use.UsageAction(plugin_id='feature_table',
                    action_id='summarize'),
    use.UsageInputs(table=clustered_table,
                    metadata=sample_metadata),
    use.UsageOutputNames(summary='clustered_table',
                         sample_frequencies='sample_frequencies',
                         feature_frequencies='otu_frequencies'))
:::
